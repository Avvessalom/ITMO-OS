## Доп вопросы к Лабораторной работе 1
1. ### Dirty/RSS - в pmap'е
   ```
    example$ pmap -x 15492
    15492:  ./maps
    Address  Kbytes     RSS    Anon  Locked Mode   Mapped File
    00010000       8       8       -       - r-x--  maps
    00020000       8       8       8       - rwx--  maps
    00022000   20344   16248   16248       - rwx--    [ heap ]
    03000000    1024    1024       -       - rw-s-  dev:0,2 ino:4628487
    04000000    1024    1024     512       - rw---  dev:0,2 ino:4628487
    05000000    1024    1024     512       - rw--R  dev:0,2 ino:4628487
    06000000    1024    1024    1024       - rw---    [ anon ]
    07000000     512     512     512       - rw--R    [ anon ]
    08000000    8192    8192       -    8192 rwxs-    [ dism shmid=0x5]
    09000000    8192    4096       -       - rwxs-    [ dism shmid=0x4]
    0A000000    8192    8192       -    8192 rwxsR    [ ism shmid=0x2 ]
    0B000000    8192    8192       -    8192 rwxsR    [ ism shmid=0x3 ]
    FF280000     680     672       -       - r-x--  libc.so.1
    FF33A000      32      32      32       - rwx--  libc.so.1
    FF390000       8       8       -       - r-x--  libc_psr.so.1
    FF3A0000       8       8       -       - r-x--  libdl.so.1
    FF3B0000       8       8       8       - rwx--    [ anon ]
    FF3C0000     152     152       -       - r-x--  ld.so.1
    FF3F6000       8       8       8       - rwx--  ld.so.1
    FFBFA000      24      24      24       - rwx--    [ stack ]
    -------- ------- ------- ------- -------
    total Kb   50464   42264   18888   16384
    ``` 
    `Adress` - начальный адресс размапленной области;
    
    `Kbytes` - размер размапленной части в килобайтах;
    
    `RSS` - сколько памяти **действительно** использует процесс. Точнее сколько реальной памяти каждый процесс занял бы, если  бы  это было единственное выполнение процесса. Дело в том, что Linux используют разделяемые библиотеки для получения  требуемой  функциональности. Linux использует  большую  уловку:  грузит  единственную копию общедоступной библиотеки  в  память и использует ее до тех пор, пока хоть одна копия программы ссылается на нее;
    RSS (resident set size) — суммарный объем всех его страничных кадров в оперативной памяти, т. е. ее реальное потребление процессом.
    
    `Dirty` - Page Cache

      Через Page Cache в Linux по умолчанию идут все операции чтения и записи. Он динамического размера, то есть именно он съест всю вашу память, если она свободна. Как гласит старая шутка, если вам нужна свободная память в сервере, просто вытащите ее из сервера.  Page Cache делит все файлы, которые мы читаем, на страницы (страница, как мы сказали, – 4 KБ).  Посмотреть, есть ли в Page Cache какие-­то страницы какого-­то конкретного файла, можно с помощью системного вызова mincore(). Или с помощью утилиты vmtouch, которая написана с использованием этого системного вызова.

      Как же происходит запись? Любая запись происходит на диск не сразу, а в Page Cache, и делается это практически моментально. Тут можно увидеть интересную «аномалию»: запись на диск идет намного быстрее, чем чтение. Дело в том, что при чтении (если данной странички файла в Page Cache нет) мы пойдем в диск и будем синхронно ждать ответа, а запись в свою очередь пройдет моментально в кеш.

      Минусом такого поведения является то, что на самом деле данные никуда не записались, — они просто находятся в памяти, и когда-­то их нужно будет сбросить на диск. У каждой странички при записи проставляется флажок (он называется dirty). Такая «грязная» страничка появляется в Page Cache. Если накапливается много таких страничек, система понимает, что пора их сбросить на диск, а то можно их потерять (если внезапно пропадет питание, наши данные тоже пропадут).

    
    `Mode` - модификаторы доступа. Если мы говорим о памяти внутри процесса, то работать со страницами тоже неудобно: как правило, выделение памяти внутри процесса происходит блоками. Очень редко требуется выделить одну­-две странички, обычно нужно выделить сразу какой-­то промежуток страниц. Поэтому в Linux существует такое понятие, как область памяти (virtual memory area, VMA), которая описывает какое-­то пространство адресов внутри виртуального адресного пространства этого процесса. На каждую такую VMA есть свои права (чтения, записи, исполнения) и области видимости: она может быть приватная или общая (которая «шарится (share)» с другими процессами в системе).

    https://linux.die.net/man/1/pmap

    https://www.opennet.ru/base/sys/pmap_memory.txt.html
    
    https://habr.com/ru/company/yandex/blog/250753/
    
    https://debianinstall.ru/pamyat-protsessa-linux/
    
2. ### Ленивое выделение памяти

   В Юниксах предыдущего поколения заказ памяти у операционной системы производился утилитами сдвига границы выделяемой памяти brk (sbrk). В современных Linux используется ленивое выделение памяти с помощью утилиты mmap, создающей анонимные отображения страниц памяти. Добавлю, что утилита brk присутствует в Линукс и реализована на базе тех же анонимных отображений.

   https://ravesli.com/urok-85-dinamicheskoe-vydelenie-pamyati-operatory-new-i-delete/#toc-1
   
   https://learnc.info/c/memory_allocation.html

   http://www.dataved.ru/2014/07/malloc-returns-cleared-memory.html
        
3. ### flock() блокировка к чему привязана
   Устанавливает или снимает advisory (мягкую, носящую рекомендательный характер) блокировку на открытый файл, заданный файловым дескриптором fd. Параметр operation может принимать одно из следующих значений:
   
    `LOCK_SH` -  Установить разделяемую блокировку. Разделяемую блокировку на заданный файл может держать более чем один процесс;
   
   `LOCK_EX` - Установить эксклюзивную блокировку. Только один процесс может держать эксклюзивную блокировку файла;
   
   `LOCK_UN` - Удалить существующую блокировку, удерживаемую данным процессом.
   
   Вызов flock() может быть блокирован, если несовместимый тип блокировки уже удерживается другим процессом.
    В случае успеха, возвращается ноль. В случае ошибки возвращается -1 и значение errno устанавливается соответствующим образом.  
    https://www.opennet.ru/man.shtml?topic=flock&category=2&russian=0

4. ### Какие данные будут общие, а какие различные у двух процессов? двух потоков?
   Разделяемая память (англ. Shared memory) является самым быстрым средством обмена данными между процессами.

   В других средствах межпроцессового взаимодействия (IPC) обмен информацией между процессами проходит через ядро, что приводит к переключению контекста между процессом и ядром, т.е. к потерям производительности.

   Техника разделяемой памяти позволяет осуществлять обмен информацией через общий для процессов сегмент памяти без использования системных вызовов ядра. Сегмент разделяемой памяти подключается в свободную часть виртуального адресного пространства процесса. Таким образом, два разных процесса могут иметь разные адреса одной и той же ячейки подключенной разделяемой памяти.

   **Краткое описание работы**

   После создания разделяемого сегмента памяти любой из пользовательских процессов может подсоединить его к своему собственному виртуальному пространству и работать с ним, как с обычным сегментом памяти. Недостатком такого обмена информацией является отсутствие каких бы то ни было средств синхронизации, однако для преодоления этого недостатка можно использовать технику семафоров.

   **В UNIX-подобных операционных системах**

   POSIX предоставляет стандартизированное API для работы с разделяемой памятью — POSIX Shared Memory. Одной из ключевых особенностей операционных систем семейства UNIX является механизм копирования процессов (системный вызов `fork()`), который позволяет создавать анонимные участки разделяемой памяти перед копированием процесса и наследовать их процессами-потомками. После копирования процесса разделяемая память будет доступна как родительскому, так и дочернему процессу. POSIX позволяет связать с объектом разделяемой памяти файловый дескриптор, что является более унифицированным механизмом, чем механизм UNIX System V.

   Потоки разделяют все сегменты за исключением стек. Потоки имеют независимые стеки вызовов, однако память в других стеках потоков по-прежнему доступна, и теоретически вы можете держать указатель на память в локальном фрейме стека другого потока (хотя, вероятно, вы должны найти лучшее место для размещения этой памяти!).

