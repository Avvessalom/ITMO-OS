## Доп вопросы к Лабораторной работе 1
1. ##### Dirty/RSS - в pmap'е
   ```
    example$ pmap -x 15492
    15492:  ./maps
    Address  Kbytes     RSS    Anon  Locked Mode   Mapped File
    00010000       8       8       -       - r-x--  maps
    00020000       8       8       8       - rwx--  maps
    00022000   20344   16248   16248       - rwx--    [ heap ]
    03000000    1024    1024       -       - rw-s-  dev:0,2 ino:4628487
    04000000    1024    1024     512       - rw---  dev:0,2 ino:4628487
    05000000    1024    1024     512       - rw--R  dev:0,2 ino:4628487
    06000000    1024    1024    1024       - rw---    [ anon ]
    07000000     512     512     512       - rw--R    [ anon ]
    08000000    8192    8192       -    8192 rwxs-    [ dism shmid=0x5]
    09000000    8192    4096       -       - rwxs-    [ dism shmid=0x4]
    0A000000    8192    8192       -    8192 rwxsR    [ ism shmid=0x2 ]
    0B000000    8192    8192       -    8192 rwxsR    [ ism shmid=0x3 ]
    FF280000     680     672       -       - r-x--  libc.so.1
    FF33A000      32      32      32       - rwx--  libc.so.1
    FF390000       8       8       -       - r-x--  libc_psr.so.1
    FF3A0000       8       8       -       - r-x--  libdl.so.1
    FF3B0000       8       8       8       - rwx--    [ anon ]
    FF3C0000     152     152       -       - r-x--  ld.so.1
    FF3F6000       8       8       8       - rwx--  ld.so.1
    FFBFA000      24      24      24       - rwx--    [ stack ]
    -------- ------- ------- ------- -------
    total Kb   50464   42264   18888   16384
    ``` 
    `Adress` - начальный адресс размапленной области;
    `Kbytes` - размер размапленной части в килобайтах;    
    `RSS` - сколько памяти **действительно** использует процесс. Точнее сколько реальной памяти каждый процесс занял бы, если  бы  это было единственное выполнение процесса. Дело в том, что Linux используют разделяемые библиотеки для получения  требуемой  функциональности. Linux использует  большую  уловку:  грузит  единственную копию общедоступной библиотеки  в  память и использует ее до тех пор, пока хоть одна копия программы ссылается на нее;
    `Dirty` - Страницы которые были изменены, но изменения еще не были записаны на диск. Ядро использует часть свободной оперативной памяти, как кеш для чтения или записи файлов. Сначала запись (или чтение) происходит в этот буфер, а затем система периодически синхронизирует данные из этого буфера с данными на диске. С помощью сисколлов sync/fsync можно инициировать синхронизацию кеша с диском. Посмотреть количество “грязной” памяти можно утилитой free -m или cat /proc/meminfo | grep Dirty;
    `Mode` - модификаторы доступа.

    https://linux.die.net/man/1/pmap
    https://www.opennet.ru/base/sys/pmap_memory.txt.html
    
2. ##### Ленивое выделение памяти
   https://ravesli.com/urok-85-dinamicheskoe-vydelenie-pamyati-operatory-new-i-delete/#toc-1
   https://learnc.info/c/memory_allocation.html
        
3. ##### flock() блокировка к чему привязана
   Устанавливает или снимает advisory (мягкую, носящую рекомендательный характер) блокировку на открытый файл, заданный файловым дескриптором fd. Параметр operation может принимать одно из следующих значений:
    `LOCK_SH` -  Установить разделяемую блокировку. Разделяемую блокировку на заданный файл может держать более чем один процесс;
    `LOCK_EX` - Установить эксклюзивную блокировку. Только один процесс может держать эксклюзивную блокировку файла;
    `LOCK_UN` - Удалить существующую блокировку, удерживаемую данным процессом.
    Вызов flock() может быть блокирован, если несовместимый тип блокировки уже удерживается другим процессом.
    В случае успеха, возвращается ноль. В случае ошибки возвращается -1 и значение errno устанавливается соответствующим образом.  
    https://www.opennet.ru/man.shtml?topic=flock&category=2&russian=0

4. ##### Какие данные будут общие, а какие различные у двух процессов? двух потоков?
