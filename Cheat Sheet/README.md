# Лабораторная работа 1
1. Как найти pid процесса без htop/top

        самый распространённый способ:  
        $ ps aux | grep имя_процесса | grep -v grep

        если нам не нужна подробная информация о процессе, а нужен только PID, то:
        $ pgrep имя_процесса
        
        следующая утилита ищет PID процесса только по точному совпадению, просто вхождения не учитываются:
        $ pidof имя_процесса

2. Всегда ли malloc переводится в mmap

        Не всегда.
         `mallopt()` можно задать параметры для управления поведением malloc() и там есть параметр с именем M_MMAP_THRESHOLD:

        * если запрошенная память меньше чем этот параметр, то будет использован brk();
        * если запрашиваемая память больше или равна ему,то будет использован mmap();

        значение параметра по умолчанию составляет 128kb (в моей системе), для тестов я использовал 1Mb,
        поэтому вызвался mmap(), когда я изменил запрошенную память на 32kb, я увидел brk().

3. Несколько способов найти адрес после malloc

        в strace посмотреть 
        
4. Как работает pthread_mutex
5. Как работают системные вызовы?

        Системные вызовы в Unix-подобных системах обрабатываются в режиме ядра, которое завершается повышением режима 
        выполнения процессора в более привилегированный, но изменение контекста процесса не требуется — однако
        при этом происходит изменение контекста привилегии.
        Системные ресурсы работают с учётом режима исполнения в соответствии со статусом регистра процессора 
        и процессы — это своего рода абстракция, предоставляемая ОС. 
        Системный вызов обычно не требует изменения контекста на другой процесс, напротив, 
        он выполняется в контексте того процесса, который его вызвал.

6. Что будет если поток не будет заjoin'инен?

        Ну не будет и не будет, чего бухтеть то? Просто закончится поток вызвав `pthread_exit()` или как нибудь еще.
        Выполнение программы продолжится как ни в чем не бывало. При завершении основного потока выполнения будут 
        убиты и созданные потоки, игнорируя то что делают потоки.
        Join-ом мы получаем данные из потока. 
        Функция pthread_join() ожидает завершения потока обозначенного THREAD_ID.
        Если этот поток к тому времени был уже завершен, то функция немедленно возвращает значение.
        Смысл функции в том, чтобы синхронизировать потоки.

7. В какие системные вызовы раскрывается pthread_create?

        openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libpthread.so.0", O_RDONLY|O_CLOEXEC) = 6
        read(6, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0 |\0\0\0\0\0\0"..., 832) = 832
        fstat(6, {st_mode=S_IFREG|0755, st_size=149608, ...}) = 0
        mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ffb222c2000
        куча mmap-ов
        close(6)
        openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 6
        read(6, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0n\2\0\0\0\0\0"..., 832) = 832
        fstat(6, {st_mode=S_IFREG|0755, st_size=1839792, ...}) = 0

8. Как stap перехватывает сисколы?

        Из скрипта stap компилируется (каждый раз при запуске stap) модуль ядра, который тут же подключается в ядро и потом 
        этот модуль перехватывает сисколы.

9. Как работает free? (Сказал начать копать с malloc)

        Функция free освобождает память, но при этом не изменяет значение указателя. 
        Переменная указатель хранит адрес области памяти, начиная с которого она может им пользоваться.
        Однако, она не хранит размера этой области. Откуда тогда функция free знает, сколько памяти необходимо освободить?

        Очевидно, что информация о размере выделенного участка должна где-то храниться. Есть несколько решения этой проблемы.

        1. Можно создать карту, в которой будет храниться размер выделенного участка. 
        Каждый раз при освобождении памяти компьютер будет обращаться к этим данным и получать нужную информацию.
        2. Второе решение более распространено. Информация о размере хранится на куче до самих данных.
        Таким образом, при выделении памяти резервируется места больше и туда записывается информация о выделенном участке.
        При освобождении памяти функция free "подсматривает", сколько памяти необходимо удалить.

10. Как работает fcntl и вцелом про работу flock’a?

        fcntrl - нужен для работы с файловыми дискрипторами
        * get, set, duplicate FD - изменение дескрипторов
        * Использование во флоках: F_GETLK, F_SETLK и F_SETLKW используются для установки, снятия и тестирования существующих 
        блокировок записи. Третий аргумент lock является указателем на структуру, которая имеет по крайней мере следующие поля.
        * F_GETOWN, F_SETOWN, F_GETSIG и F_SETSIG используются для управления сигналами доступности ввода/вывода.

11. MMAP: Anon - ?

        MAP_ANONYMOUS / MAP_ANON это флаг использующийся для создания анонимного маппинга.
        Анонимный маппинг значит, что он не связан ни с какими файлами. Используется, как основной примитив для расширения кучи.
12. Почему лучше не делать все переменные атомик? Почему лучше оставлять другие?
13. Почему не безопасно делать sprintf? 

        потому что не чекает размер буфера, куда записывает строку

14. Что делает ptread create?

        Создаёт новый поток. Далее, вызывающая сторона продолжает выполнять какие-то свои действия параллельно 
        потоковой функции. При удачном завершении pthread_create() возвращает код 0, ненулевое значение
        сигнализирует об ошибке.

```c 
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                void *(*start)(void *), void *arg);
```
        * Первый параметр вызова pthread_create() является адресом для хранения идентификатора создаваемого
        потока типа pthread_t.
        * Аргумент start является указателем на потоковую void * функцию, принимающей бестиповый указатель
        в качестве единственной переменной.
        * Аргумент arg — это бестиповый указатель, содержащий аргументы потока. Чаще всего arg указывает
        на глобальную или динамическую переменную, но если вызываемая функция не требует наличия аргументов,
        то в качестве arg можно указать NULL.
        * Аргумент attr также является бестиповым указателем атрибутов потока pthread_attr_t.
        Если этот аргумент равен NULL, то поток создается с атрибутами по умолчанию
  
15. Что будет если мы выделим память с mmap(MAP_ANON) как то так, потом форкнем процесс и будем читать и писать
из этого региона памяти?

        Если будем читать, то прочитаем из памяти родительского процесса, если будем писать, то система скопирует память
        и запишет в неё.

16. Что такое грязные странички?
        
        Страницы которые изменены, но изменения не были записаны на диск еще.
        
17. Как работает своп?

18. Откуда проги типа iostat и iotop берут информацию о вводе-выводе?

19. Что значит слово extern для компилятора?

20. Что такое O_TRUNC при вызове open?

21. Что такое файловый дескриптор?

22. Почему плохо лишний раз вызывать malloc?
